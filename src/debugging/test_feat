#include <Arduino.h>
#include <Wire.h>
#include <algorithm>
#include <iostream>
#include "fft.h"
#define FFT_N 32 // Must be a power of 2 >= 32

float acc_x_data[] = {
    0.192, 0.172, 0.196, 0.182, 0.196, 0.192, 0.165, 0.18,  0.172, 0.18, 0.194, 0.187, 0.196, 0.208, 0.182, 0.199,
    0.187, 0.189, 0.172, 0.187, 0.204, 0.199, 0.189, 0.177, 0.206, 0.16, 0.189, 0.201, 0.175, 0.199, 0.199, 0.199,
};

float acc_y_data[] = {0.048, 0.055, 0.043, 0.036, 0.022, 0.045, 0.060, 0.045, 0.034, 0.055, 0.048,
                      0.045, 0.043, 0.038, 0.038, 0.055, 0.050, 0.041, 0.038, 0.031, 0.024, 0.031,
                      0.041, 0.041, 0.060, 0.053, 0.055, 0.043, 0.024, 0.041, 0.053, 0.034};

float acc_z_data[] = {10.362, 10.372, 10.353, 10.372, 10.357, 10.381, 10.364, 10.403, 10.367, 10.364, 10.405,
                      10.376, 10.4,   10.369, 10.367, 10.362, 10.384, 10.381, 10.391, 10.398, 10.372, 10.408,
                      10.379, 10.396, 10.384, 10.364, 10.367, 10.374, 10.319, 10.362, 10.374, 10.348};

float gyro_x_data[] = {-0.009, -0.009, -0.007, -0.009, -0.009, -0.009, -0.009, -0.009, -0.009, -0.009, -0.008,
                       -0.009, -0.009, -0.009, -0.007, -0.008, -0.009, -0.008, -0.009, -0.008, -0.009, -0.008,
                       -0.009, -0.008, -0.008, -0.009, -0.009, -0.009, -0.009, -0.009, -0.008, -0.009};

float gyro_y_data[] = {0.015, 0.014, 0.015, 0.015, 0.016, 0.015, 0.014, 0.015, 0.015, 0.015, 0.014,
                       0.013, 0.014, 0.014, 0.014, 0.015, 0.015, 0.015, 0.014, 0.015, 0.015, 0.014,
                       0.014, 0.014, 0.014, 0.014, 0.014, 0.014, 0.014, 0.014, 0.015, 0.015};

float gyro_z_data[] = {-0.016, -0.017, -0.017, -0.016, -0.017, -0.016, -0.017, -0.017, -0.017, -0.015, -0.015,
                       -0.017, -0.015, -0.016, -0.016, -0.015, -0.015, -0.015, -0.016, -0.016, -0.016, -0.015,
                       -0.016, -0.016, -0.016, -0.016, -0.016, -0.017, -0.017, -0.017, -0.015, -0.016};

float FFT_input[FFT_N];
float FFT_output[FFT_N];
int window_size = 32; // Window size

float
production_cubic(float x, float y, float z) {
    float results = 0;
    float prod = fabs(x * y * z);
    results = pow(prod, 1.0 / 3);
    return results;
}

/*
float
compute_energy(float* data, int len) {
    float sum = 0;
    for (int i = 0; i < len; i++) {
        sum += fabs(data[i] * data[i]);
    }
    return sum / len;
}
*/
float
window_max(float* data, int len) {
    float max_val = data[0];
    for (int i = 1; i < len; i++) {
        if (data[i] > max_val) {
            max_val = data[i];
        }
    }
    return max_val;
}

float
window_mean(float* data, int len) {
    float sum = 0;
    for (int i = 0; i < len; i++) {
        sum += data[i];
    }
    return sum / len;
}

/*
float
window_min(float* data, int len) {
    float min_val = data[0];
    for (int i = 1; i < len; i++) {
        if (data[i] < min_val) {
            min_val = data[i];
        }
    }
    return min_val;
}
*/
float
compute_mad(float* data, int len) {
    float mean = window_mean(data, len);
    float sum = 0;
    for (int i = 0; i < len; i++) {
        sum += fabs(data[i] - mean);
    }
    return sum / len;
}

float
compute_iqr(float* data, int len) {
    std::sort(data, data + len);
    float q1 = data[len / 4];
    float q3 = data[3 * len / 4];
    return q3 - q1;
}

float
compute_rms(float* data, int len) {
    float sum = 0;
    for (int i = 0; i < len; i++) {
        sum += fabs(data[i] * data[i]);
    }
    return sqrt(sum) / len;
}

void
compute_FFT(float* input, float* output, int size) {
    FFT_real myFFT(FFT_N);
    float FFT_input[FFT_N];
    float FFT_output[FFT_N];
    // Example: Fill input with acc_x_data
    for (int i = 0; i < FFT_N; i++) {
        FFT_input[i] = input[i];
    }
    myFFT.setInput(FFT_input);
    myFFT.compute();
    float* result = myFFT.getOutput();
    for (int i = 0; i < FFT_N; i++) {
        output[i] = result[i];
    }
}

void
setup() {
    Serial.begin(115200);
}

void
loop() {

    float fft_acc_x[FFT_N];
    compute_FFT(acc_x_data, fft_acc_x, window_size);

    float output_matrix[window_size][10]; // Initialize output matrix

    float f0 = 0, f1[FFT_N], f2[window_size], f3 = 0, f4 = 0, f5 = 0, f6 = 0, f7 = 0, f8 = 0,
          f9 = 0; // initialize features

    f0 = compute_iqr(gyro_y_data, window_size); // IQR_gyro y
    // f1 = fft_acc_x;                          // FFT_acceleration x
    for (int i = 0; i < window_size; i++) {
        f2[i] = production_cubic(gyro_x_data[i], gyro_y_data[i],
                                 gyro_z_data[i]); // Production Cubic Magnitude of Angular Velocity
    }
    f3 = compute_iqr(gyro_z_data, window_size); // IQR_gyro z
    f4 = fabs(window_mean(gyro_x_data, window_size)) + fabs(window_mean(gyro_y_data, window_size))
         + fabs(window_mean(gyro_z_data, window_size)); // Signal Magnitude Area Gyroscope
    f5 = window_max(gyro_z_data, window_size);          // acceleration_z_window_max
    f6 = window_mean(acc_z_data, window_size);          // acceleration_z_window_mean
    f7 = compute_rms(acc_z_data, window_size);          // RMS_acceleration_z
    f8 = compute_mad(acc_x_data, window_size);          // MAD_acceleration_x
    f9 = window_max(acc_y_data, window_size);           // acceleration_y_window_max

    // Fill matrix
    for (int i = 0; i < window_size; i++) {

        output_matrix[i][0] = f0;           // IQR_gyro y
        output_matrix[i][1] = fft_acc_x[i]; // FFT_acceleration x
        output_matrix[i][2] = f2[i];        // Production Cubic Magnitude of Angular Velocity
        output_matrix[i][3] = f3;           // IQR_gyro z
        output_matrix[i][4] = f4;           // Signal Magnitude Area Gyroscope
        output_matrix[i][5] = f5;           // acceleration_z_window_max
        output_matrix[i][6] = f6;           // acceleration_z_window_mean
        output_matrix[i][7] = f7;           // RMS_acceleration_z
        output_matrix[i][8] = f8;           // MAD_acceleration_x
        output_matrix[i][9] = f9;           // acceleration_y_window_max
    }

    Serial.println("\n=== Output Matrix (32x10) ===");
    for (int i = 0; i < window_size; i++) {
        for (int j = 0; j < 10; j++) {
            Serial.printf("%.3f,", output_matrix[i][j]);
        }
        Serial.println();
    }

    /*
    Serial.println("\n=== FFT_output ===");
    for (int i = 0; i < FFT_N; i++) {
        Serial.printf("%.3f\t", FFT_output[i]);
        
    }
    */

    Serial.println();
    delay(100);
}